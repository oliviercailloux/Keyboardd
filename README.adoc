= Keyboardd

A keyboard drawer library. Can be used to parse and manipulate keyboard maps and display them as SVG, so as to represent a given keyboard layout or keyboard shortcuts.
Includes support for XKB governed systems, including Wayland, but may be useful (and runs) on other systems.

== Mappings
The system file `evdev` maps X keycodes to X key names; local configuration files map X key names to keysym entries; and the system file `xkbcommon-keysyms.h` maps (mainly) keysym mnemonics to keysym codes and Unicode code points. See figure <<XM>> and read below for details.

.X mappings
[[XM]]
image::https://github.com/oliviercailloux/XKB-doc/blob/main/X%20mappings.svg[Mappings and sources, opts=inline]


== Preliminary
You need to understand at least roughly (preferably, deeply) https://github.com/oliviercailloux/XKB-doc/blob/main/README.adoc[how keyboards work under XKB]. Sorry for this.

== Usage (short)
Define manually a json physical row keyboard: that’s easy. Set special widths only where needed.
Parse that jsonphysicalRowKeyboard and obtain a PhysicalKeyboard, write this as SVG, getting a keyboard with correct computed positions.
Modify the SVG manually.

I have some impression that FF (Firefox uses GTK3 on my system) prints at 96 DPI. Eog seems to print at 72 DPI (configurable). Let’s go for 96 DPI for the standard.

== This library
Here is a quick overview of the main concepts (by class name) that this library permits to manipulate.
The terms are defined https://github.com/oliviercailloux/XKB-doc/blob/main/README.adoc#Concepts[here].

* `XKeys`: can be obtained using `EvdevReader`
* `Mnemonics`: can be obtained using `KeySymsReader`; can be used to obtain a `UcpByCode`
* `KeyboardMap`: can be obtained using `SimpleSymbolsReader`
* `RectangularKeyboard`: can be parsed from json using `JsonRectangularKeyboardReader`
* `Representation`: a String or an SVG icon
* `VisibleKeyboardMap`: combines a keyboard map and a mapping from keysym entry to representation
* `SvgKeyboard`: read from and produce https://github.com/oliviercailloux/SVG-keyboard[svg keyboard files]; a rectangular svg keyboard can be produced by combining a `RectangularKeyboard` and a `VisibleKeyboardMap`; a more complex svg keyboard can be produced by combining an SVG keyboard and a `VisibleKeyboardMap`.

== Vocabulary

The code uses the following terms and abbreviations.

* `name` is an X key name (when not specifying whether it’s a canonical name or an alias)
* `canonical name` (previously `canonical`, to be changed) is an X key name that is not an alias
* `alias name` (or `alias`, to be changed) is an X key name that is an alias
* `code` as `short` is an X keycode
* `code` as `int` is a keysym code
* `mnemonic` is a keysym mnemonic (when not specifying whether it’s a canonical mnemonic or an alias)
* `canonical mnemonic` is a keysym mnemonic that is not an alias
* `alias mnemonic`

The argument names use the non-abbreviated names; the method and class names use the abbreviated names (unless an abbreviated name would raise some ambiguity). For example: `nameFromMnemonic(keysymMnemonic: String)`

For example, an argument that represents a canonical X key name is (following the https://google.github.io/styleguide/javaguide.html#s5.3-camel-case[GJSG], despite https://github.com/checkstyle/checkstyle/issues/14239#issuecomment-1883019025[disagreement]) `canonicalXKeyName`.

== SVG keyboards
This library produces https://github.com/oliviercailloux/SVG-keyboard/blob/main/README.adoc[SVG keyboards] that target a given physical size so as to represent the keys and the keyboard with a scale of 1:1. To do this, the library assumes that the viewer (or printer) uses 96 DPI. SVG keyboards that this library produces therefore have a size in pixels, equivalently (given the DPI value), a size in cm.
(If no size is set, “the browser should fall back to a size of [300px × 150px as an] outer <svg> element is technically a replaced element as far as the html/css specifications are concerned” -- https://stackoverflow.com/questions/65625935/how-does-chrome-determines-svg-size/65626536#65626536[SO]; as “when the referenced resource does not have an intrinsic size” -- https://svgwg.org/svg2-draft/embedded.html#Placement[SVG2 spec]; and there seems to be no way to implicitly set the size to the size of the content -- https://stackoverflow.com/questions/50813950/how-do-i-make-an-svg-size-to-fit-its-content/50820586#50820586[SO]; also no viewBox is used (“This attribute provides a convenient way to design SVG documents to scale-to-fit into an arbitrary SVG viewport” -- https://svgwg.org/svg2-draft/struct.html#SVGElement[SVG2 spec]) so that the keyboard does not change size (TODO check).)

Key bindings may be represented by embedded SVG documents. Such documents may themselves have a native size in pixels (thus, still assuming 96 DPI, a native size in cm). This is useful if the embedded SVG document contains letters in a font that should be represented exactly at 10px, for example. Which in turn is useful for uniformity accross keys. This also permits to use a drawing that represents the key cap and whose size represents the physical size of the keyboard key cap.
Thus, if the given SVG documents (to be embedded) have a size, the library will respect this size and center the document in the key binding zone. If the document is too large, it will be resized to fit the zone (TODO check).

Headers follow the https://svgwg.org/svg2-draft/struct.html#NewDocument[SVG2 spec].

== Limitations
This library represents in the same way a key mapping using UCP written as U+xxxx, using the character, or using the mnemonic. But internally, X may use different codes. For example the mnemonic “exclam” with keysym code 0x21 and the mnemonic absent with keysym code 0x1000021 corresponding to U+0021 EXCLAMATION MARK. This happens for most mnemonics defined from lines 0 to 1800, then not for most mnemonics defined from lines 1800 to 3200.
It https://github.com/xkbcommon/libxkbcommon/issues/433[might be] that keyboard shortcuts differ, for example.
