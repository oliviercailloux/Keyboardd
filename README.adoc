= Keyboardd

A keyboard drawer library, to be used on systems governed by XKB (including Wayland). Can be used to parse and manipulate keyboard maps and display them as SVG, so as to represent a given keyboard layout or keyboard shortcuts.

== Preliminary
You need to understand at least roughly (preferably, deeply) https://github.com/oliviercailloux/XKB-doc/README.adoc[how keyboards work under XKB]. Sorry for this.

== This library

Here is a quick overview of the main concepts (by class name) that this library permits to manipulate.
The terms are defined https://github.com/oliviercailloux/XKB-doc/README.adoc#Concepts[here].

* `XKeys`: can be obtained using `EvdevReader`
* `Mnemonics`: can be obtained using `KeySymsReader`; can be used to obtain a `UcpByCode`
* `KeyboardMap`: can be obtained using `SimpleSymbolsReader`
* `RectangularKeyboard`: can be parsed from json using `JsonRectangularKeyboardReader`
* `Representation`: a String or an SVG icon
* `VisibleKeyboardMap`: combines a keyboard map and a mapping from keysym entry to representation
* `SvgKeyboard`: read from and produce svg keyboard files; a rectangular svg keyboard can be produced by combining a `RectangularKeyboard` and a `VisibleKeyboardMap`; a more complex svg keyboard can be produced by combining an SVG keyboard and a `VisibleKeyboardMap`.

Keysym UCPs

* Map (non bijective, incomplete) from keysym code to UCP
* Implicit: Map UCP to keysym code (bijective, complete), when inverted is a bijective, incomplete
* Can be obtained from Implicit
* Explicit: can be obtained from Keysym mnemonics (combining keysym code to canonical keysym mnemonic then keysym mnemonic to UCP)
* Both: implicit and explicit combined (resulting map still incomplete as some keysym code that explicitly corresponds to some canonical keysym mnemonic may have no associated UCP)
* Can be obtained from lib? TODO

A map from X to Y is complete iff its set of keys equals the set of legal values for X. When a map is specified to be non bijective or incomplete, it means: not necessarily bijective, not necessarily complete.
A map is a function that knows its set of keys and values.

// Keysym representations

// * Map (non bijective, complete) from keysym code to representation
// * Can be obtained from Keysym UCPs (typically through keysym UCPs both; keeps only printable UCPs)
// * Can be obtained from Keysym UCPs together with Keysym mnemonics (fall backs on the mnemonics if no printable UCP; the resulting map is complete)
// * Provide “falling back to” method? TODO
// * Note that these maps must compute. TODO

// Encoded keyboard map

// * Map (non bijective, incomplete) from X key name to a list of encoded keysym entries
// * An encoded keysym entry is a keysym mnemonic and keysym code, a UCP and keysym code or a keysym code
// * Can be obtained from a Keyboard map and a Keysym mnemonics and a Keysym UCPs?

Visible keyboard map

* Map (non bijective, incomplete) from X key name to a list of representations
* Does _not_ contain a Keyboard map (so that can be used for any display of keyboard shortcuts such as for VSCode)
* Can be obtained from a Keyboard map and a mapping from keysym entry to representation
* Direct: a mapping from keysym entry to representation (as close as possible to the raw source) from a Keysym mnemonics and a Keysym UCPs and a map (non bijective, incomplete) from UCP to representation: transform a keysym code to its UCP or canonical mnemonic if no printable UCP, a keysym mnemonic to its natural string representation, and UCP to representation.
* Canonic: a mapping from keysym entry to representation (canonicalizing as much as possible then using the provided transformations) from a Keysym mnemonics and a Keysym UCPs and a map (non bijective, incomplete) from keysym canonical mnemonic to representation and a map (non bijective, incomplete) from UCP to representation: transform a keysym code to its canonical mnemonic or UCP if no mnemonic, a keysym mnemonic to its canonical mnemonic, a canonical mnemonic to UCP (using the Keysym mnemonics) or to representation if no UCP, and UCP to representation.

Functional keyboard

* A set of functional keys
* A functional key is a position and a list of representations
* Can be obtained from a Physical keyboard and a Visible keyboard map

SVG keyboardd: includes a “key representation zone” for each key (and other elements as desired). A key representation zone is an SVG rectangle with an attribute that indicates the (canonical?) X key name. (Do not need to be unique; the only limitation is that if they are duplicated, they will also always have the same representation, which I think is reasonable, though it is permitted to add attributes to distinguish them.) The SVG may draw complex shapes for each key; may use the key representation zone to draw the key or make it invisible… When rewriting the file using representations, our classes will delete every SVG element that is entirely (weakly) inside a key representation zone.

SVG physical keyboardd: an SVG keyboardd where the key representation zone is an element that draws the x key name.

SVG functional keyboardd: an SVG keyboardd where the key representation zone contains one or more representations that illustrate the behavior of the key (in a large sense, so representing what is displayed on the keyboard is allowed, including if all keys are black as for a blind keyboard). As a file format, this is therefore equivalent to an SVG keyboardd, but as a class concept it differs as its purpose is to use the mappings defined in the OS.

We also need a standard attribute "key-id" to identify keys that do not send anything, such as the Fn key (and to distinguish keys with identical x-key-name if this exists).

== Vocabulary

The code uses the following terms and abbreviations.

* `name` is an X key name (when not specifying whether it’s a canonical name or an alias)
* `canonical name` (or `canonical`, to be changed) is an X key name that is not an alias
* `alias name` (or `alias`, to be changed) is an X key name that is an alias
* `code` as `short` is an X keycode
* `code` as `int` is a keysym code
* `mnemonic` is a keysym mnemonic (when not specifying whether it’s a canonical mnemonic or an alias)
* `canonical mnemonic` is a keysym mnemonic that is not an alias
* `alias mnemonic`

The argument names use the non-abbreviated names; the method and class names use the abbreviated names (unless an abbreviated name would raise some ambiguity). For example: `nameFromMnemonic(keysymMnemonic: String)`

For example, an argument that represents a canonical X key name is (following the https://google.github.io/styleguide/javaguide.html#s5.3-camel-case[GJSG]) `canonicalXKeyName`.
(BTW, anybody please tell me if you https://github.com/checkstyle/checkstyle/issues/14239#issuecomment-1883019025[agree with romani]; I can’t figure out the way they see this.)

== SVG
svg global : a une taille en cm. Pour l’affichage à l’écran ; l’impression.
Ceci détermine la taille d’une touche en cm.
Ceci détermine la taille d’une zone.
Si on me donne un SVG sans taille, je l’étend sur la zone.
Si le SVG a une taille, je la respecte et met le SVG au centre de la zone si ça rentre. Si le SVG est trop grand, je le rétréci à la taille de la zone.

SVG doc
	<?xml version="1.0" standalone="yes"?>
	https://svgwg.org/svg2-draft/struct.html#NewDocument
	
SVG taille ?
	https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html
	https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started
	https://svgwg.org/svg2-draft/struct.html
	
Apache ?
	https://svgwg.org/svg2-draft/types.html#InterfaceSVGElement
	The SVGGraphicsElement interface represents SVG elements whose primary purpose is to directly render graphics into a group.
	The getBBox method is used to compute the bounding box of the current element.

https://sourceforge.net/p/axsl/code/HEAD/tree/trunk/svg-dom/src/main/resources/
https://central.sonatype.com/artifact/org.axsl.org.w3c.dom.svg/svg-dom-java
https://www.javadoc.io/doc/org.axsl.org.w3c.dom.svg/svg-dom-java/latest/index.html
https://xmlgraphics.apache.org/batik/javadoc/ (should give up on batik which relies on SVG 1.0, says sourceforge, https://stackoverflow.com/questions/13676937/how-to-find-package-org-w3c-dom-svg)
https://www.w3.org/TR/SVG11/java.html
https://www.javadoc.io/doc/org.apache.xmlgraphics/xmlgraphics-commons/latest/index.html
https://www.javadoc.io/doc/org.apache.xmlgraphics/batik-all/latest/index.html
https://xmlgraphics.apache.org/batik/using/scripting/java.html (might include batik-all or some similar stuff, to get SVG 1.0, to get the BBox; though this is incompatible with the SVG 1.1 interface as it uses the same class names): https://stackoverflow.com/questions/34078251/getbbox-for-embedded-svg-element-with-batik

== Usage
Define manually a json physical row keyboard: that’s easy. Set special widths only where needed.
Parse that jsonphysicalRowKeyboard and obtain a PhysicalKeyboard, write this as SVG, getting a keyboard with correct computed positions.
Modify the SVG manually.

== Notes
This library represents in the same way a key mapping using UCP written as U+xxxx, using the character, or using the mnemonic. But internally, X may use different codes. For example the mnemonic “exclam” with keysym code 0x21 and the mnemonic absent with keysym code 0x1000021 corresponding to U+0021 EXCLAMATION MARK. This happens for most mnemonics defined from lines 0 to 1800, then not for most mnemonics defined from lines 1800 to 3200.
It https://github.com/xkbcommon/libxkbcommon/issues/433[might be] that keyboard shortcuts differ, for example.

== TODO
Ask https://github.com/xkbcommon/libxkbcommon/issues/433[] about the squareroot stuff (which I confirmed again on 14 janv), probable oversight as all other such cases are deprecated: period and decimalpoint, less and leftcaret, underscore and underbar, macron and overbar, topleftradical and upleftcorner, horizconnector and horizlinescan5, includedin and leftshoe, …. Then a given mnemonic maps to one UCP that maps to no other mnemonic than this one (though it generally maps to two codes!). But, anyway, let’s assume that this does not matter: any X system should act the same whatever the code mapping to a given (non-specific) UCP? (Though if specific ones are distinct, then maybe also non specific ones!)
Maybe rather at https://gitlab.freedesktop.org/xorg/proto/xorgproto/-/issues[].

Finish test, using a clean fr mapping. Why is it not displaying the unicode equivalent?
Embed an SVG document as representation (not just an element!). How to do this cleanly?
Allow mapping from multiple fr-like files?
Checkstyle and XKeyName?

== From notes in drawer
    /*
     * Also, key F1 sends keycode 67, F2 sends keycode 68, Fn+F1 sends keycode 179, sym XF86Tools
     * (269025153), Fn+F2 sends keycode 122, sym XF86AudioLowerVolume (269025041). evdev maps
     * keycode 179 to I179 and keycode 122 to VOL-.
     * 
     */

    /*
     * We want to render at chosen font size, so no scaling. Thus, we have to choose the key size
     * accordingly. It is hopeless to display the real key size (in real cm), however (requires
     * knowing the number of dpi). But we can print it. I have some impression that FF prints at 96
     * DPI. Eog seems to print at 72 DPI (configurable). Let’s go for 96 DPI for the standard.
     * 
     * Firefox uses GTK3 on my system.
     */
    /* Requires Batik for BBox (on SVGSVGElement or SVGLocatable or such). */

This should be used after parsing the simple layout json file, to scale the physical keyboard, then output another json file.

    double defaultHeight = 1.4d;
    double defaultWidth = 1.25d;
    /* inter h varies. Average is 29.6 cm for total length for 16 standard keys and 15 sep. */
    double interH = (29.6d - 16d * defaultWidth) / 15d;
    verify(DoubleMath.fuzzyEquals(interH, 0.64d, 1e-4d));
    double interV = 0.52d;
    /* Total height is 11 cm (measured), that is 6*height + 5*interV. */

== Libraries

https://gitlab.freedesktop.org/xorg/lib/libx11/-/blob/master/src/xkb/XKBBind.c[impl] of XkbKeycodeToKeysym, XKeycodeToKeysym, XKeysymToKeycode and more complicated functions (https://gitlab.freedesktop.org/xorg/lib/libx11/-/blob/master/src/KeyBind.c[older one]; some related https://github.com/mirror/libX11/blob/master/src/xkb/XKBlibint.h[headers]). https://gitlab.freedesktop.org/xorg/lib/libx11/blob/master/src/StrKeysym.c[Impl] of XStringToKeysym only.

** See mainly: https://github.com/xkbcommon/libxkbcommon/blob/238d132406d8dc1123cbcaf68ab12d34c505e7e4/include/xkbcommon/xkbcommon.h#L168-L204[impl] of libxkbcommon xkb_keysym_get_name, xkb_keysym_from_name, xkb_keysym_to_utf8, xkb_keymap_num_layouts_for_key and so on.

On my Debian system:

* libxkbcommon-x11-0 (mandatory) https://packages.debian.org/bookworm/libxkbcommon-x11-0 “This package provides an add-on library called xkbcommon-x11, to support creating keymaps with the XKB X11 protocol, by querying the X server directly.”
* libxkbcommon0 (mandatory) https://packages.debian.org/bookworm/libxkbcommon0
* libx11-6
* libx11-data
* libx11-dev, requiring https://packages.debian.org/bookworm/all/x11proto-dev/filelist, containing /usr/include/X11/keysymdef.h, but non mandatory
* I can load the "X11" library and call XStringToKeysym("KP_Space"). “XKeycodeToKeysym predates the XKB extension. If you want to lookup a KeySym while using XKB you have to use XkbKeycodeToKeysym.” -- https://linux.die.net/man/3/xstringtokeysym 
* xkbkeycodetokeysym https://linux.die.net/man/3/xkbkeycodetokeysym 

TODO integrate https://who-t.blogspot.com/2021/01/auto-updating-xkb-for-new-kernel.html
Also integrate https://github.com/xkbcommon/libxkbcommon/blob/6073565903488cb5b9a8d37fdc4a7c2f9d7ad04d/include/xkbcommon/xkbcommon.h#L204
